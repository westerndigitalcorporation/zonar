// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * SPDX-FileCopyrightText: 2026 Western Digital Corporation or its affiliates.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <math.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <adwaita.h>

#include "znr.h"

/*
 * GUI blockgroups, contains the required data for rendering a blockgroups
 * and supporting per blockgroup extent tabs.
 */
struct znr_gui_blockgroup {
	unsigned int		bg_no;
	struct znr_bg		*bg;
	GtkWidget		*da;
	bool			hovered;

	struct znr_gui_extents_tab *tab;
};

/*
 * Extents dialog tab data.
 */
struct znr_gui_extents_tab {
	AdwTabPage		*page;

	struct znr_fs_file	*file;
	struct znr_gui_blockgroup *blockgroup;

	struct znr_extent	*extents;
	unsigned int		nr_extents;
};

/* Convert macros to string for CSS properties */
#define STRINGIFY(x)    #x
#define TOSTRING(x)     STRINGIFY(x)

/* CSS constants */
#define ZNR_GUI_BLOCKGROUP_MARGIN     2
#define ZNR_GUI_BLOCKGROUP_MARGINS    (ZNR_GUI_BLOCKGROUP_MARGIN * 2)

static const char *znr_gui_css_data =
	/* Scrollbar styling */
	"scrollbar.vertical slider {"
	"   min-width: 10px;"
	"}"
	/* Frame border styling (Device Info/Search Box) */
	"frame {"
	"   border: 2px solid #727272ff;"
	"   border-radius: 5px;"
	"}"
	/* Blockgroup grid background color */
	"flowbox {"
	"   background-color: #8a8484ff;"
	"}"
	"gridview {"
	"   background-color: #8a8484ff;"
	"}"
	"gridview > child {"
	"   padding: 0px;"
	"   margin: " TOSTRING(ZNR_GUI_BLOCKGROUP_MARGIN) "px;"
	"}"
	/* Auto refresh toggle button active state */
	"button.auto-refresh:checked {"
	"   background-color: #468ee6ff;"
	"   color: white;"
	"}";

/* GUI constants */
#define ZNR_GUI_MAX_ZOOM_OUT		10
#define	ZNR_GUI_MIN_REFRESH_MS		200

/*
 * GUI data.
 */
struct znr_gui {
	/*
	 * For handling signals.
	 */
	int			abort;
	GIOChannel		*gio_channel;
	int			sig_pipe[2];

	/*
	 * GUI stuff.
	 */
	GdkRGBA			color_conv;
	GdkRGBA			color_seq;
	GdkRGBA			color_seqw;
	GdkRGBA			color_text;
	GdkRGBA			color_jz;
	GdkRGBA			color_extent;
	GtkWidget		*window;
	GtkWidget		*legend_frame;
	GtkWidget		*show_blockgroup_entry;
	GtkWidget		*refresh_ms_entry;
	GtkWidget		*bg_status;
	GtkWidget		*search_entry;
	GtkWidget		*search_file;
	GtkWidget		*grid_view;
	GListStore		*blockgroup_list;

	/*
	 * Tracks visible blockgroup drawing areas for updates
	 */
	GHashTable		*drawing_areas;
	unsigned long long	visible_blockgroups_no;

	/*
	 * Blockgroup grid control.
	 */
	unsigned int		zoom_level;
	unsigned int		nr_col;
	unsigned int		nr_col_min;
	GtkWidget		*scroll_window;
	/* Track if we are jumping to a blockgroup, so we can highlight it */
	unsigned int		show_blockgroup;

	/* Blockgroup extents window management*/
	GtkWidget		*extents_dialog;
	AdwTabView		*extents_tab_view;

	/*
	 * The GUI will do a blockgroup report for only the blockgroups in
	 * view every refresh_ms milli-seconds.
	 */
	unsigned int		refresh_ms;
};

static struct znr_gui znrg;

#define ZNR_TYPE_BLOCKGROUP_ITEM	znr_blockgroup_item_get_type()
G_DECLARE_FINAL_TYPE(znr_blockgroup_item, znr_blockgroup_item,
		     ZNR, BLOCKGROUP_ITEM, GObject)

struct _znr_blockgroup_item {
	GObject parent;
	unsigned int bg_no;
	struct znr_bg *bg;
};

G_DEFINE_TYPE(znr_blockgroup_item, znr_blockgroup_item, G_TYPE_OBJECT)

static GtkWidget *znr_gui_create_grid(void);

static void znr_blockgroup_item_init(znr_blockgroup_item *item)
{
	item->bg_no = 0;
	item->bg = NULL;
}

/*
 * Note: znr_blockgroup_itemClass is generated by the macro above, hence
 * we can't avoid the camelcase.
 */
static void znr_blockgroup_item_class_init(znr_blockgroup_itemClass *class) {}

static znr_blockgroup_item *znr_blockgroup_item_new(unsigned int bg_no,
						    struct znr_bg *bg)
{
	znr_blockgroup_item *item =
		g_object_new(ZNR_TYPE_BLOCKGROUP_ITEM, NULL);

	item->bg_no = bg_no;
	item->bg = bg;

	return item;
}

static void znr_gui_update(void);

static void znr_gui_err(const char *msg, const char *fmt, ...)
{
	AdwAlertDialog *dialog;
	va_list args;
	char secondary[256];

	dialog = ADW_ALERT_DIALOG(adw_alert_dialog_new(msg, NULL));
	adw_alert_dialog_set_heading_use_markup(dialog, TRUE);
	adw_alert_dialog_set_body_use_markup(dialog, FALSE);

	if (fmt) {
		va_start(args, fmt);
		vsnprintf(secondary, sizeof(secondary), fmt, args);
		va_end(args);

		adw_alert_dialog_set_body(dialog, secondary);
	}

	adw_dialog_set_content_width(ADW_DIALOG(dialog), 450);
	gtk_widget_set_size_request(GTK_WIDGET(dialog), 450, -1);
	adw_alert_dialog_add_response(dialog, "close", "Close");
	adw_alert_dialog_set_response_appearance(dialog, "close",
						 ADW_RESPONSE_SUGGESTED);
	adw_alert_dialog_set_default_response(dialog, "close");
	adw_dialog_present(ADW_DIALOG(dialog), znrg.window);
}

static struct znr_gui_extents_tab *znr_gui_get_current_extents_tab(void)
{
	AdwTabPage *page;

	if (!znrg.extents_tab_view)
		return NULL;

	page = adw_tab_view_get_selected_page(ADW_TAB_VIEW(znrg.extents_tab_view));

	return g_object_get_data(G_OBJECT(page), "tab");
}

/*
 * Build extent information string for a file or a specific blockgroup.
 * Returns allocated string that must be freed by the caller, or NULL on error
 */
static char *znr_gui_extent_info(struct znr_extent *extents,
				 unsigned int nr_extents,
				 struct znr_fs_file *file)
{
	char *buf = NULL;
	size_t buf_size;
	size_t buf_offset = 0;
	unsigned int i;
	size_t len;

	/*
	 * Allocate buffer for extent information:
	 * - Header: ~300 bytes (file path + extent count)
	 * - Per extent: ~256 characters
	 * - Safety margin: one extent.
	 */
	buf_size = 400 + (nr_extents + 1) * ZNR_FS_EXT_INFO_SIZE;
	buf = calloc(buf_size, 1);
	if (!buf) {
		fprintf(stderr,
			"Failed to allocate memory for extent info\n");
		return NULL;
	}

	if (file)
		buf_offset = snprintf(buf, buf_size,
				      "<tt>"
				      "<b>File</b>:          %s\n"
				      "<b>Inode</b>:         %llu\n"
				      "</tt>",
				      file->path,
				      file->ino);

	if (!nr_extents) {
		buf_offset +=
			snprintf(buf + buf_offset, buf_size - buf_offset,
				 "\n<tt><i>No extents in this %s</i></tt>",
				 file ? "file" : "blockgroup");
		return buf;
	}

	buf_offset += snprintf(buf + buf_offset, buf_size - buf_offset,
			       "<tt><b>Total Extents</b>: %u</tt>\n\n",
			       nr_extents);

	for (i = 0; i < nr_extents; i++) {
		len = strlen(extents[i].info);
		if (len > buf_size - buf_offset) {
			fprintf(stderr,
				"Extent information buffer overflow\n");
			goto out_err;
		}

		strncpy(buf + buf_offset, extents[i].info,
			buf_size - buf_offset);
		buf_offset += len;
	}

	return buf;

out_err:
	free(buf);
	return NULL;
}

static int znr_gui_report_blockgroups(unsigned int bg_start,
				      unsigned int nr_blockgroups)
{
	int ret;

	if (bg_start >= znr.nr_blockgroups)
		return 0;

	if (bg_start + nr_blockgroups > znr.nr_blockgroups)
		nr_blockgroups = znr.nr_blockgroups - bg_start;

	/* Get blockgroup information */
	ret = znr_bg_refresh(&znr.dev, znr.blk_zones, znr.nr_zones,
			     znr.blockgroups, bg_start, nr_blockgroups);
	if (ret < 0) {
		fprintf(stderr, "Get blockgroup information failed %d (%s)\n",
			errno, strerror(errno));
		return ret;
	}

	if ((unsigned int)ret != nr_blockgroups) {
		fprintf(stderr, "Got %d blockgroups, expected %u blockgroups\n",
			ret, nr_blockgroups);
		return -EIO;
	}

	return 0;
}

struct znr_gui_blockgroup_report_info {
        unsigned int starting_blockgroup;
        unsigned int nr_blockgroups;
};

/*
 * Doing a large blockgroup report can be expensive to drives with a large
 * number of zones, in such cases, the GUI can lock up while the operation is
 * pending. Instead, this function is to be called from a g_idle_add() context.
 * This allows the GUI to not lock up at the cost of slightly delaying a
 * blockreport.
 */
static gboolean znr_gui_deferred_report_blockgroups(gpointer data)
{
        struct znr_gui_blockgroup_report_info *bg_rep = data;
        unsigned int start = bg_rep->starting_blockgroup;
        unsigned int nr_bgs = bg_rep->nr_blockgroups;
        int ret;

        ret = znr_gui_report_blockgroups(start, nr_bgs);
	if (ret) {
		znr_gui_err("Report Blockgroup Failed",
			    "Blockgroup %u, %u blockgroups failed (%s)",
			    start, nr_bgs, strerror(ret));
                goto out;
	}

        znr_gui_update();
out:
        free(data);
        return G_SOURCE_REMOVE;
}

static void znr_gui_update(void)
{
	GHashTableIter iter;
	gpointer key, value;

	if (!znrg.drawing_areas)
		return;

	/*
	 * The drawing_areas hash table tracks all currently-bound drawing areas
	 * (blockgroups visible in the grid). znr_gui_update() is typically
	 * invoked when there are changes (e.g., extents change). So let's queue
	 * a redraw on all drawing areas to refresh blockgroup display.
	 */
	g_hash_table_iter_init(&iter, znrg.drawing_areas);
	while (g_hash_table_iter_next(&iter, &key, &value))
		gtk_widget_queue_draw(GTK_WIDGET(value));
}

static void znr_gui_blockgroup_draw_written(struct znr_bg *bg, cairo_t *cr,
					    int width, int height)
{
	long long w;

	if (!bg->nr_zones)
		return;

	if (bg->wp_sector == 0)
		return;

	/* Written space in blockgroup */
	w = (long long)width *
		bg->wp_sector / bg->nr_sectors;
	if (w > width)
		w = width;

	gdk_cairo_set_source_rgba(cr, &znrg.color_seqw);
	cairo_rectangle(cr, 0, 0, w, height);
	cairo_fill(cr);
}

static void znr_gui_blockgroup_draw_num(struct znr_gui_blockgroup *blockgroup,
					cairo_t *cr, int width, int height)
{
	cairo_text_extents_t te;
	char str[16];

	/* Draw blockgroup number */
	gdk_cairo_set_source_rgba(cr, &znrg.color_text);
	cairo_select_font_face(cr, "Monospace",
			       CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
	cairo_set_font_size(cr, 10);

	snprintf(str, sizeof(str), "%u", blockgroup->bg_no);
	cairo_text_extents(cr, str, &te);
	cairo_move_to(cr,
		      width / 2 - te.width / 2 - te.x_bearing,
		      height / 2 - te.height / 2 - te.y_bearing);
	cairo_show_text(cr, str);
}

static bool znr_gui_blockgroup_tab_open(struct znr_gui_blockgroup *blockgroup,
					struct znr_gui_extents_tab **ext_tab)

{
	AdwTabPage *page;
	struct znr_gui_extents_tab *tab;
	struct znr_gui_extents_tab *in_focus = znr_gui_get_current_extents_tab();
	int nr_pages, i;

	if (!in_focus->blockgroup)
		return false;

	nr_pages = adw_tab_view_get_n_pages(znrg.extents_tab_view);
	for (i = 0; i < nr_pages; ++i) {
		page = adw_tab_view_get_nth_page(znrg.extents_tab_view, i);
		if (!page)
			continue;

		tab = g_object_get_data(G_OBJECT(page), "tab");
		if (!tab || !tab->blockgroup)
			continue;

		if (blockgroup == tab->blockgroup) {
			*ext_tab = tab;
			return true;
		}
	}

	*ext_tab = NULL;
	return false;
}

static bool
znr_gui_should_draw_blockgroup_extents(struct znr_gui_blockgroup *blockgroup,
				       struct znr_gui_extents_tab **ext_tab)
{
	struct znr_gui_extents_tab *tab = znr_gui_get_current_extents_tab();

	if (!tab)
		return false;

	if (!blockgroup || !blockgroup->bg)
		return false;

	if (!znrg.extents_tab_view)
		return false;

	/*
	 * If a blockgroup tab is in focus, allow drawing extents for all
	 * blockgroup tabs
	 */
	if (znr_gui_blockgroup_tab_open(blockgroup, ext_tab))
		return true;

	/* If a file tab is in focus, draw extents for that file */
	if (tab->file) {
		*ext_tab = tab;
		return true;
	}

	return false;
}

static inline bool znr_gui_extent_in_blockgroup(struct znr_extent *ext,
						struct znr_bg *bg)
{
	return ext->sector >= bg->sector &&
		ext->sector + ext->nr_sectors <= bg->sector + bg->nr_sectors;
}

static void
znr_gui_blockgroup_draw_extents(struct znr_gui_blockgroup *blockgroup,
				cairo_t *cr, int width, int height)
{
	unsigned long long bg_sect, bg_len;
	struct znr_gui_extents_tab *tab = NULL;
	struct znr_bg *bg = blockgroup->bg;
	double x, y, w, h, ext_x, ext_w;
	cairo_text_extents_t te;
	struct znr_extent *ext;
	unsigned int i;
	char str[16];

	if (!znr_gui_should_draw_blockgroup_extents(blockgroup, &tab))
		return;

	bg_sect = bg->sector;
	bg_len = bg->nr_sectors;

	/* Set up drawing style and line width for the extents highlight. */
	gdk_cairo_set_source_rgba(cr, &znrg.color_extent);
	cairo_set_font_size(cr, 10);
	cairo_set_line_width(cr, 3);
	cairo_select_font_face(cr, "Monospace",
			       CAIRO_FONT_SLANT_NORMAL,
			       CAIRO_FONT_WEIGHT_BOLD);

	/* Set drawing area with small margin */
	x = 1;
	y = 1;
	w = width - 2;
	h = height - 2;

	for (i = 0; i < tab->nr_extents; i++) {
		ext = &tab->extents[i];
		if (!znr_gui_extent_in_blockgroup(ext, bg))
			continue;

		/*
		 * Calculate the extent rectangle position and width as a
		 * percentage of the blockgroup.
		 */
		ext_x = ((ext->sector - bg_sect) * w) / bg_len;
		ext_w = (ext->nr_sectors * w) / bg_len;

		/* Draw extent rectangle (no colour fill) */
		cairo_rectangle(cr, x + ext_x, y, ext_w, h);
		cairo_stroke(cr);

		/* Draw extent number */
		sprintf(str, "%d", ext->idx);
		cairo_text_extents(cr, str, &te);

		/*
		 * With heavily fragmented files, only draw the extent number
		 * if it fits in the extent
		 */
		if (te.width > ext_w / 2)
			continue;

		cairo_move_to(cr,
			x + ext_x + ext_w / 2 - te.width / 2 - te.x_bearing,
			y + h - 10);
		cairo_show_text(cr, str);
	}
}

static void znr_gui_blockgroup_draw_cb(GtkDrawingArea *drawing_area,
				       cairo_t *cr, int width, int height,
				       gpointer user_data)
{
	struct znr_gui_blockgroup *blockgroup = user_data;
	struct znr_bg *bg = blockgroup->bg;
	char info[256];
	char wp[32];
	char type[32];
	char usage [8];
	GdkRGBA fg_color;

	if (!bg)
		return;

	/* Draw blockgroup background based on type in flags field */
	if (bg->flags == BLK_ZONE_TYPE_CONVENTIONAL) {
		gdk_cairo_set_source_rgba(cr, &znrg.color_conv);
	} else if (bg->flags == BLK_ZONE_TYPE_SEQWRITE_REQ) {
		gdk_cairo_set_source_rgba(cr, &znrg.color_seq);
	} else {
		fprintf(stderr, "Unknown blockgroup type: %u\n", bg->flags);
		gdk_cairo_set_source_rgba(cr, &znrg.color_seq);
	}
	cairo_rectangle(cr, 0, 0, width, height);
	cairo_fill(cr);

	znr_gui_blockgroup_draw_written(bg, cr, width, height);

	/* Draw file extents */
	znr_gui_blockgroup_draw_extents(blockgroup, cr, width, height);

	/* Draw blockgroup number */
	znr_gui_blockgroup_draw_num(blockgroup, cr, width, height);

	/* Draw selection highlight if blockgroup is selected */
	if (blockgroup && znrg.show_blockgroup != UINT_MAX &&
	    blockgroup->bg_no == znrg.show_blockgroup) {
		gdk_cairo_set_source_rgba(cr, &znrg.color_jz);
		cairo_set_line_width(cr, 4);
		cairo_rectangle(cr, 2, 2, width - 4, height - 4);
		cairo_stroke(cr);
		znrg.show_blockgroup = UINT_MAX;
	}

	/* Draw hover highlight if blockgroup is hovered */
	if (blockgroup && blockgroup->hovered) {
		gtk_widget_get_color(blockgroup->da, &fg_color);
		gdk_cairo_set_source_rgba(cr, &fg_color);
		cairo_set_line_width(cr, 3);
		cairo_rectangle(cr, 1, 1, width - 2, height - 2);
		cairo_stroke(cr);

		/* Render Blockgroup info in hover overview */
		if (bg->flags == BLK_ZONE_TYPE_SEQWRITE_REQ) {
			if (bg->nr_zones == 1 &&
			    bg->zones[0]->cond == BLK_ZONE_COND_FULL) {
				snprintf(wp, sizeof(wp), "N/A");
				snprintf(usage, sizeof(usage), "100%%");
			} else if (bg->nr_zones == 1) {
				snprintf(wp, sizeof(wp), "0x%lx", bg->wp_sector);
				snprintf(usage, sizeof(usage), "%lu%%",
					 bg->wp_sector * 100 / bg->nr_sectors);
			} else {
				/* todo: Likely RAID, we need to revise */
				snprintf(wp, sizeof(wp), "Unknown");
				snprintf(usage, sizeof(usage), "N/A");
				fprintf(stderr,
					"Unsupported number of zones in blockgroups");
			}

			snprintf(type, sizeof(type), "Sequential Write Required");
		} else if (bg->flags == BLK_ZONE_TYPE_CONVENTIONAL) {
			snprintf(wp, sizeof(wp), "N/A");
			snprintf(type, sizeof(type), "Conventional");
			snprintf(usage, sizeof(usage), "N/A");
		} else {
			snprintf(wp, sizeof(wp), "Unknown");
			snprintf(type, sizeof(type), "Unknown");
			snprintf(usage, sizeof(usage), "Unknown");
		}

		snprintf(info, sizeof(info),
			 "Blockgroup [%u]: %s • Start: 0x%lx Size: 0x%lx sectors • WP: %s • Usage: %s",
			 blockgroup->bg_no, type, bg->sector, bg->nr_sectors,
			 wp, usage);
		gtk_editable_set_text(GTK_EDITABLE(znrg.bg_status), info);
	}
}

static gboolean znr_gui_blockgroup_enter_cb(GtkWidget *widget,
					    gpointer user_data)
{
	struct znr_gui_blockgroup *blockgroup = user_data;

	if (!blockgroup || !widget || !blockgroup->da)
		return FALSE;

	blockgroup->hovered = true;
	gtk_widget_queue_draw(blockgroup->da);

	return FALSE;
}

static gboolean znr_gui_blockgroup_leave_cb(GtkWidget *widget,
					    gpointer user_data)
{
	struct znr_gui_blockgroup *blockgroup = user_data;

	if (!blockgroup || !widget || !blockgroup->da)
		return FALSE;

	blockgroup->hovered = false;
	gtk_widget_queue_draw(blockgroup->da);

	return FALSE;
}

static void znr_gui_close_extents_tab(struct znr_gui_extents_tab *tab)
{
	if (!tab || !tab->page)
		return;

	g_object_set_data(G_OBJECT(tab->page), "tab", (gpointer)NULL);
	if (tab->blockgroup)
		tab->blockgroup->tab = NULL;
	else if (tab->file)
		znr_fs_free_file(tab->file);

	free(tab->extents);
	free(tab);
}

static void znr_gui_close_all_extents_tabs(void)
{
	struct znr_gui_extents_tab *tab;
	AdwTabPage *page;
	int nr_pages, i;

	if (!znrg.extents_dialog)
		return;

	nr_pages = adw_tab_view_get_n_pages(znrg.extents_tab_view);
	for (i = 0; i < nr_pages; ++i) {
		page = adw_tab_view_get_nth_page(znrg.extents_tab_view, i);
		if (!page)
			return;
		tab = g_object_get_data(G_OBJECT(page), "tab");
		znr_gui_close_extents_tab(tab);
	}
}

static void znr_gui_close_extents_dialog(void)
{
	if (!znrg.extents_dialog)
		return;

	znr_gui_close_all_extents_tabs();
	gtk_window_close(GTK_WINDOW(znrg.extents_dialog));

	znrg.extents_tab_view = NULL;
	znrg.extents_dialog = NULL;

	znr_gui_update();
}

static void
znr_gui_extents_dialog_close_cb(GtkWidget *widget __attribute__((unused)),
				gpointer user_data)
{
	znr_gui_close_extents_dialog();
}

static gboolean znr_gui_extents_tab_close_cb(AdwTabView *tab_view,
					AdwTabPage *page, gpointer user_data)
{
	struct znr_gui_extents_tab *tab;

	/* If this is the last tab, close the entire dialog */
	if (adw_tab_view_get_n_pages(tab_view) == 1) {
		znr_gui_close_extents_dialog();
		return GDK_EVENT_STOP;
	}

	tab = (struct znr_gui_extents_tab *)
		g_object_get_data(G_OBJECT(page), "tab");
	if (tab) {
		znr_gui_close_extents_tab(tab);
		znr_gui_update();
	}

	return GDK_EVENT_PROPAGATE;
}

static void znr_gui_extents_tab_focus_cb(GObject *object, GParamSpec *pspec,
					 gpointer __attribute__((unused)))
{
	struct znr_gui_extents_tab *tab = znr_gui_get_current_extents_tab();

	if (!tab)
		return;

	if (tab->blockgroup) {
		znrg.show_blockgroup = tab->blockgroup->bg_no;
		gtk_grid_view_scroll_to(GTK_GRID_VIEW(znrg.grid_view),
					tab->blockgroup->bg_no,
					GTK_LIST_SCROLL_FOCUS, NULL);
	}

	znr_gui_update();
}

static void znr_gui_open_extents_dialog(void)
{
	GtkEventController *controller;
	GtkWidget *tab_toolbar;
	AdwTabBar *tab_bar;
	GtkWidget *dialog;

	if (znrg.extents_dialog)
		return;

	/*
	 * Default libadwaita behavior is to hide tabs if N tabs == 1.
	 * Having the blockgroup number visible at all times in the tab
	 * is useful, so disable autohide.
	 */
	znrg.extents_tab_view = adw_tab_view_new();
	tab_bar = adw_tab_bar_new();
	adw_tab_bar_set_autohide(tab_bar, false);
	adw_tab_bar_set_view(tab_bar, znrg.extents_tab_view);

	tab_toolbar = adw_toolbar_view_new();
	adw_toolbar_view_add_top_bar(ADW_TOOLBAR_VIEW(tab_toolbar),
				     GTK_WIDGET(tab_bar));
	adw_toolbar_view_set_content(ADW_TOOLBAR_VIEW(tab_toolbar),
				     GTK_WIDGET(znrg.extents_tab_view));

	dialog = gtk_window_new();
	gtk_window_set_child(GTK_WINDOW(dialog),
			     GTK_WIDGET(tab_toolbar));
	gtk_window_set_default_size(GTK_WINDOW(dialog), 700, 500);
	gtk_window_set_title(GTK_WINDOW(dialog), "Extents Information");
	gtk_window_set_modal(GTK_WINDOW(dialog), false);
	gtk_window_set_resizable(GTK_WINDOW(dialog), true);
	gtk_window_set_destroy_with_parent(GTK_WINDOW(dialog), true);
	gtk_window_set_transient_for(GTK_WINDOW(dialog),
				     GTK_WINDOW(znrg.window));
	znrg.extents_dialog = dialog;

	controller = gtk_event_controller_focus_new();
	gtk_widget_add_controller(dialog, controller);

	g_signal_connect(dialog, "close-request",
			 G_CALLBACK(znr_gui_extents_dialog_close_cb),
			 NULL);
	g_signal_connect(znrg.extents_tab_view, "close-page",
			 G_CALLBACK(znr_gui_extents_tab_close_cb),
			 NULL);
	g_signal_connect(znrg.extents_tab_view,
			 "notify::selected-page",
			 G_CALLBACK(znr_gui_extents_tab_focus_cb), NULL);
	gtk_window_present(GTK_WINDOW(dialog));
}

static struct znr_gui_extents_tab *
znr_gui_add_extents_dialog_tab(char *tab_label,
			       GtkTextBuffer *tab_text_buffer)
{
	GtkWidget *extents_view, *extents_scroll, *extents_text;
	struct znr_gui_extents_tab *tab;

	tab = calloc(1, sizeof(*tab));
	if (!tab) {
		znr_gui_err("Failed to allocate new tab", NULL);
		return NULL;
	}

	/* Make sure we have an extents dialog window. */
	znr_gui_open_extents_dialog();

	/* Scrolled window for the tab text */
	extents_view = adw_view_stack_new();
	extents_scroll = gtk_scrolled_window_new();
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(extents_scroll),
				GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_widget_set_hexpand(extents_scroll, TRUE);
	gtk_widget_set_vexpand(extents_scroll, TRUE);

	extents_text = gtk_text_view_new();
	gtk_text_view_set_buffer(GTK_TEXT_VIEW(extents_text), tab_text_buffer);
	gtk_text_view_set_editable(GTK_TEXT_VIEW(extents_text), FALSE);
	gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(extents_text), FALSE);

	gtk_text_view_set_top_margin(GTK_TEXT_VIEW(extents_text), 10);
	gtk_text_view_set_left_margin(GTK_TEXT_VIEW(extents_text), 20);
	gtk_text_view_set_right_margin(GTK_TEXT_VIEW(extents_text), 10);
	gtk_text_view_set_bottom_margin(GTK_TEXT_VIEW(extents_text), 50);

	gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(extents_scroll),
				      extents_text);

	adw_view_stack_add_titled_with_icon(ADW_VIEW_STACK(extents_view),
					    extents_scroll,
					    tab_label, tab_label,
					    "info-outline-symbolic");

	/* Add a new tab for this blockgroup */
	tab->page = adw_tab_view_append(znrg.extents_tab_view, extents_view);
	adw_tab_page_set_title(tab->page, tab_label);
	g_object_set_data(G_OBJECT(tab->page), "tab", (gpointer)tab);
	adw_tab_view_set_selected_page(znrg.extents_tab_view, tab->page);

	return tab;
}

static void znr_gui_blockgroup_click_cb(GtkGestureClick *self, gint n_press,
					gdouble x, gdouble y,
					gpointer user_data)
{
	struct znr_gui_blockgroup *blockgroup =
		(struct znr_gui_blockgroup *)user_data;
	struct znr_gui_extents_tab *tab;
	GtkTextBuffer *text_buffer;
	struct znr_extent *extents;
	unsigned int nr_extents;
	GtkTextIter iter;
	char *extents_info = NULL;
	char info[256];
	char tab_label[32], *bg_info;
	int ret;

	if (!blockgroup || !blockgroup->bg)
		return;

	/* If the blockgroup already has a tab, focus it. */
	if (blockgroup->tab) {
		adw_tab_view_set_selected_page(znrg.extents_tab_view,
					       blockgroup->tab->page);
		return;
	}

	/* Update the blockgroup */
	ret = znr_gui_report_blockgroups(blockgroup->bg_no, 1);
	if (ret) {
		znr_gui_err("Report Blockgroup Failed",
			    "Report blockgroups for blockgroup %u failed (%s)",
			    blockgroup->bg_no, strerror(errno));
		return;
	}

	/* Get all extents in the clicked blockgroup */
	ret = znr_fs_get_extents_in_range(blockgroup->bg->sector,
					  blockgroup->bg->nr_sectors,
					  &extents, &nr_extents);
	if (ret) {
		znr_gui_err("Failed to get blockgroup extents\n", NULL);
		return;
	}

	/* Build extent information string */
	extents_info = znr_gui_extent_info(extents, nr_extents, NULL);
	if (!extents_info) {
		znr_gui_err("Failed to get extent information\n", NULL);
		return;
	}

	/* Set the extents information text. */
	text_buffer = gtk_text_buffer_new(NULL);
	gtk_text_buffer_get_start_iter(text_buffer, &iter);

	if (blockgroup->bg->wp_sector >= blockgroup->bg->nr_sectors)
		snprintf(info, sizeof(info),
			 "<b>Blockgroup %u</b>\nSector: %lu\nSize: %lu sectors\nWP: N/A (Blockgroup full) \n\n",
			 blockgroup->bg_no, blockgroup->bg->sector,
			 blockgroup->bg->nr_sectors);
	else
		snprintf(info, sizeof(info),
			 "<b>Blockgroup %u</b>\nSector: %lu\nSize: %lu sectors\nWP: %lu\n\n",
			 blockgroup->bg_no, blockgroup->bg->sector,
			 blockgroup->bg->nr_sectors, blockgroup->bg->wp_sector);
	bg_info = info;
	gtk_text_buffer_insert_markup(text_buffer, &iter, bg_info,
				      strlen(bg_info));
	gtk_text_buffer_insert_markup(text_buffer, &iter, extents_info,
				      strlen(extents_info));
	free(extents_info);

	/* Open the tab */
	snprintf(tab_label, sizeof(tab_label), "Blockgroup %u",
		 blockgroup->bg_no);
	tab = znr_gui_add_extents_dialog_tab(tab_label, text_buffer);
	if (!tab)
		return;

	blockgroup->tab = tab;
	tab->blockgroup = blockgroup;
	tab->extents = extents;
	tab->nr_extents = nr_extents;

	znr_gui_update();
}

static void znr_gui_draw_legend(char *str, const GdkRGBA *color, cairo_t *cr,
				gint *x, gint y, GtkWidget *widget)
{
	cairo_text_extents_t te;
	GdkRGBA fg_color;
	gint w = 10;

	/* Get foreground color from theme */
	gtk_widget_get_color(widget, &fg_color);

	/* Draw box border with theme foreground color */
	gdk_cairo_set_source_rgba(cr, &fg_color);
	cairo_set_line_width(cr, 2);
	cairo_rectangle(cr, *x, y - w / 2, w, w);
	cairo_stroke_preserve(cr);

	/* Fill box with blockgroup color */
	gdk_cairo_set_source_rgba(cr, color);
	cairo_fill(cr);
	*x += w;

	/* Draw text with theme foreground color */
	gdk_cairo_set_source_rgba(cr, &fg_color);
	cairo_text_extents(cr, str, &te);
	cairo_move_to(cr,
		      *x + 5 - te.x_bearing,
		      y - te.height / 2 - te.y_bearing);
	cairo_show_text(cr, str);
	*x += te.x_advance + 20;
}

static void znr_gui_draw_legend_cb(GtkDrawingArea *drawing_area,
				   cairo_t *cr,
				   int width  __attribute__((unused)),
				   int height  __attribute__((unused)),
				   gpointer user_data  __attribute__((unused)))
{
	gint x = 10, y = 10;
	GtkWidget *widget = GTK_WIDGET(drawing_area);

	/* Set font */
	cairo_select_font_face(cr, "Monospace",
			       CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
	cairo_set_font_size(cr, 10);

	/* Blockgroup spans conventional zones legend */
	znr_gui_draw_legend("Conventional",
			    &znrg.color_conv, cr, &x, y, widget);

        /*
         * If the device is not zoned, until we can display an allocation
         * pointer for emulated zones, keeps sequential unwritten/written
         * legends hidden.
         */
        if (znr.dev.is_zoned) {
                /* Blockgroup spans sequential zones legend */
                znr_gui_draw_legend("Sequential (Unwritten)",
                                    &znrg.color_seq, cr, &x, y, widget);

                x = 10;
                y *= 3;

                /* Sequential written zones legend */
                znr_gui_draw_legend("Sequential (Written)",
                                    &znrg.color_seqw, cr, &x, y, widget);
        }

	/* Extent highlight legend */
	znr_gui_draw_legend("File Extent",
			    &znrg.color_extent, cr, &x, y, widget);
}

static void znr_gui_blockgroup_da_size(int *width, int *height)
{
	/* Use a 2.5 : 1 aspect ratio for a blockgroup drawing area size */
	if (width)
		*width = znrg.zoom_level * 15;
	if (height)
		*height = znrg.zoom_level * 6;
}

/*
 * Helper to resize a single drawing area widget
 */
static void znr_gui_resize_drawing_area(gpointer key, gpointer value,
					gpointer user_data)
{
	GtkWidget *da = GTK_WIDGET(value);
	int zw, zh;

	znr_gui_blockgroup_da_size(&zw, &zh);
	gtk_widget_set_size_request(da, zw, zh);
	gtk_widget_queue_resize(da);
}

/*
 * Resize the blockgroup grid to new dimensions by updating blockgroup sizes
 */
static void znr_gui_resize_grid(unsigned int new_zoom_level)
{
	int gw, zw;

	if (!znrg.grid_view)
		return;

	/* Update zoom level */
	znrg.zoom_level = new_zoom_level;

	/* Recalculate number of columns based on new blockgroup size */
	gw = gtk_widget_get_width(znrg.scroll_window);
	znr_gui_blockgroup_da_size(&zw, NULL);
	znrg.nr_col = gw / zw;

	/* Update grid column count */
	gtk_grid_view_set_max_columns(GTK_GRID_VIEW(znrg.grid_view),
				      znrg.nr_col);
	gtk_grid_view_set_min_columns(GTK_GRID_VIEW(znrg.grid_view),
				      znrg.nr_col);

	/* Resize all currently visible drawing areas */
	if (znrg.drawing_areas)
		g_hash_table_foreach(znrg.drawing_areas,
				     znr_gui_resize_drawing_area, NULL);
}

/*
 * Zoom out: increase rows and columns (show more blockgroups).
 */
static void znr_gui_zoom_out_cb(GtkWidget *widget __attribute__((unused)),
				gpointer user_data __attribute__((unused)))
{
	unsigned int new_zoom_level;

	/* Already at max zoom out */
	if (znrg.zoom_level == ZNR_GUI_MAX_ZOOM_OUT)
		return;

	new_zoom_level = znrg.zoom_level - 2;

	/* Limit maximum grid size */
	if (new_zoom_level >= 2)
		znr_gui_resize_grid(new_zoom_level);
}

/*
 * Zoom in: decrease rows and columns (show fewer blockgroups).
 */
static void znr_gui_zoom_in_cb(GtkWidget *widget __attribute__((unused)),
			       gpointer user_data __attribute__((unused)))
{
	unsigned int new_zoom_level = znrg.zoom_level + 2;

	/* Limit minimum grid size */
	if (new_zoom_level <= 30)
		znr_gui_resize_grid(new_zoom_level);
}

static int znr_gui_get_first_blockgroup_in_view(unsigned int *first_blockgroup)
{
	GtkAdjustment *vadj;
	int first_row;
	int bgh;
	int row_pitch;

	znr_gui_blockgroup_da_size(NULL, &bgh);
	row_pitch = bgh + ZNR_GUI_BLOCKGROUP_MARGINS;

	if (!znrg.scroll_window)
		return -EINVAL;

	vadj = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(
                znrg.scroll_window));
	if (!vadj)
		return -EINVAL;

	first_row = gtk_adjustment_get_value(vadj) / row_pitch;
	*first_blockgroup = first_row * znrg.nr_col;

	return 0;
}

static gboolean znr_gui_refresh_local_cb(gpointer user_data)
{
	unsigned int first_blockgroup = 0;

	if (znr_gui_get_first_blockgroup_in_view(&first_blockgroup))
		znr_gui_err("Failed to refresh local blockgroups\n", NULL);

	if (znrg.visible_blockgroups_no > znr.nr_blockgroups) {
		fprintf(stderr, "Invalid visible blockgroups number: %lld\n",
			znrg.visible_blockgroups_no);
		return G_SOURCE_REMOVE;
	}

	znr_gui_close_extents_dialog();
	znr_gui_report_blockgroups(first_blockgroup,
				   znrg.visible_blockgroups_no);
	znr_gui_update();

	if (znrg.refresh_ms >= ZNR_GUI_MIN_REFRESH_MS)
		return G_SOURCE_CONTINUE;
	return G_SOURCE_REMOVE;
}

static void znr_gui_refresh_ms_check_cb(GtkWidget *widget,
				gpointer user_data __attribute__((unused)))
{
	const char *text;
	char *endptr;
	unsigned long long refresh_ms;
	bool active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));

	if (active) {
		text = gtk_editable_get_text(GTK_EDITABLE(znrg.refresh_ms_entry));
		errno = 0;
		refresh_ms = strtoull(text, &endptr, 10);
		if (errno || endptr == text || *endptr != '\0' ||
		    refresh_ms < ZNR_GUI_MIN_REFRESH_MS) {
			znr_gui_err("Invalid Input",
				    "Enter a valid period (Minimum %dms)",
				    ZNR_GUI_MIN_REFRESH_MS);
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget),
						     FALSE);
			return;
		}
		znrg.refresh_ms = refresh_ms;
		g_timeout_add(znrg.refresh_ms, znr_gui_refresh_local_cb, NULL);
	} else {
		znrg.refresh_ms = 0;
	}
}

static void znr_gui_refresh_cb(GtkWidget *widget __attribute__((unused)),
			       gpointer user_data __attribute__((unused)))
{
        struct znr_gui_blockgroup_report_info *bg_rep;

        bg_rep = calloc(1, sizeof(struct znr_gui_blockgroup_report_info));
        if (!bg_rep) {
                fprintf(stderr, "Out of memory for blockgroup report\n");
                return;
        }

        znr_gui_close_extents_dialog();
        bg_rep->starting_blockgroup = 0;
        bg_rep->nr_blockgroups = znr.nr_blockgroups;
        g_idle_add(znr_gui_deferred_report_blockgroups, bg_rep);
}

static void
znr_gui_show_blockgroup_cb(GtkWidget *button __attribute__((unused)),
			   gpointer user_data __attribute__((unused)))
{
	const char *text;
	char *endptr;
	long bg_no;

	text = gtk_editable_get_text(GTK_EDITABLE(znrg.show_blockgroup_entry));
	if (!text || !strlen(text))
		return;

	errno = 0;
	bg_no = strtol(text, &endptr, 10);
	if (errno == ERANGE || endptr == text || *endptr != '\0' ||
	    bg_no < 0 || (unsigned long)bg_no >= znr.nr_blockgroups) {
		znr_gui_err("Invalid blockgroup number",
			    "Blockgroup: %s", text);
		gtk_editable_set_text(GTK_EDITABLE(znrg.show_blockgroup_entry),
				      "");
		return;
	}

	gtk_grid_view_scroll_to(GTK_GRID_VIEW(znrg.grid_view), bg_no,
				GTK_LIST_SCROLL_FOCUS, NULL);
	gtk_editable_set_text(GTK_EDITABLE(znrg.show_blockgroup_entry), "");

	/* When the grid updates, this blockgroup will be selected */
	znrg.show_blockgroup = bg_no;
	znr_gui_update();
}

static void znr_gui_clear_file_search_entry(void)
{
	gtk_editable_set_text(GTK_EDITABLE(znrg.search_entry), "");
	znr_gui_update();
}

static void znr_gui_search_file_cb(GtkWidget *button, gpointer user_data)
{
        struct znr_gui_blockgroup_report_info *bg_rep;
	struct znr_gui_extents_tab *tab;
	struct znr_fs_file *f = NULL;
	GtkTextBuffer *text_buffer;
	struct znr_extent *extents;
	unsigned int nr_extents;
	GtkTextIter iter;
	char *extents_info;
	char tab_label[256];
	const char *text;
	int ret;

	text = gtk_editable_get_text(GTK_EDITABLE(znrg.search_entry));
	if (!text || !strlen(text))
		return;

	/* Get extents for the file by bath */
        ret = znr_fs_get_file_extents_by_path(text, &f, &extents, &nr_extents);
        if (ret) {
                znr_gui_err("Failed to get file extents",
			    "File: %s/%s\nError: %s",
                            znr.mnt_dir.path, text,
                            strerror(errno));
                znr_gui_clear_file_search_entry();
                return;
        }

	/* Build extent information string */
	extents_info = znr_gui_extent_info(extents, nr_extents, f);
	if (!extents_info) {
		znr_gui_err("Failed to get extent information\n", NULL);
		return;
	}

        bg_rep = calloc(1, sizeof(struct znr_gui_blockgroup_report_info));
        if (!bg_rep) {
                fprintf(stderr, "Out of memory for blockgroup report\n");
                return;
        }

        bg_rep->starting_blockgroup = 0;
        bg_rep->nr_blockgroups = znr.nr_blockgroups;
        g_idle_add(znr_gui_deferred_report_blockgroups, bg_rep);

	/* Set the extents information text. */
	text_buffer = gtk_text_buffer_new(NULL);
	gtk_text_buffer_get_start_iter(text_buffer, &iter);
	gtk_text_buffer_insert_markup(text_buffer, &iter, extents_info,
				      strlen(extents_info));
	free(extents_info);

	/* Open the tab */
	snprintf(tab_label, sizeof(tab_label), "File %s", f->path);
	tab = znr_gui_add_extents_dialog_tab(tab_label, text_buffer);
	if (!tab)
		return;

	tab->file = f;
	tab->extents = extents;
	tab->nr_extents = nr_extents;

}

/* This should only be called when it is required to grow the drawing area */
static void znr_gui_grid_setup_cb(GtkListItemFactory *factory,
				  GtkListItem *list_item, gpointer user_data)
{
	GtkWidget *da = gtk_drawing_area_new();
	int zw, zh;

	znr_gui_blockgroup_da_size(&zw, &zh);
	gtk_widget_set_size_request(da, zw, zh);

	gtk_widget_set_halign(da, GTK_ALIGN_FILL);
	gtk_widget_set_valign(da, GTK_ALIGN_FILL);
	gtk_widget_set_vexpand(da, TRUE);
	gtk_widget_set_hexpand(da, TRUE);

	gtk_list_item_set_child(list_item, da);
}

static void znr_gui_grid_bind_cb(GtkListItemFactory *factory,
				 GtkListItem *list_item, gpointer user_data)
{
	struct znr_gui_blockgroup *blockgroup = NULL;
	znr_blockgroup_item *bg_item;
	GtkWidget *da;
	GtkEventController *ctrl;
	GtkGesture *gesture;

	bg_item = ZNR_BLOCKGROUP_ITEM(gtk_list_item_get_item(list_item));
	da = gtk_list_item_get_child(list_item);

	blockgroup = g_object_get_data(G_OBJECT(da), "blockgroup_data");
	if (!blockgroup) {
		/* First time binding */
		blockgroup = g_new0(struct znr_gui_blockgroup, 1);
		blockgroup->da = da;
		g_object_set_data_full(G_OBJECT(da), "blockgroup_data",
				       blockgroup, g_free);

		/* Setup event handlers */
		ctrl = gtk_event_controller_motion_new();
		gtk_widget_add_controller(da,
					  GTK_EVENT_CONTROLLER(ctrl));

		g_signal_connect(ctrl, "enter",
				 G_CALLBACK(znr_gui_blockgroup_enter_cb),
				 blockgroup);
		g_signal_connect(ctrl, "leave",
				 G_CALLBACK(znr_gui_blockgroup_leave_cb),
				 blockgroup);

		gesture = gtk_gesture_click_new();
		gtk_gesture_single_set_button(GTK_GESTURE_SINGLE(gesture),
					      GDK_BUTTON_PRIMARY);
		gtk_widget_add_controller(da, GTK_EVENT_CONTROLLER(gesture));
		g_signal_connect(gesture, "pressed",
				 G_CALLBACK(znr_gui_blockgroup_click_cb),
				 blockgroup);
	}

	/* Update blockgroup data for current item */
	blockgroup->bg_no = bg_item->bg_no;
	blockgroup->bg = bg_item->bg;
	blockgroup->hovered = false;

	/* Track drawing area for updates */
	if (znrg.drawing_areas) {
		g_hash_table_insert(znrg.drawing_areas, da, da);
		znrg.visible_blockgroups_no++;
	}
	gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(da),
				       znr_gui_blockgroup_draw_cb,
				       blockgroup,
				       NULL);
}

static void znr_gui_grid_unbind_cb(GtkListItemFactory *factory,
				      GtkListItem *list_item,
				      gpointer user_data)
{
	GtkWidget *da = gtk_list_item_get_child(list_item);

	if (!da)
		return;

	/* Remove from tracking hash table */
	if (znrg.drawing_areas) {
		g_hash_table_remove(znrg.drawing_areas, da);
		if (znrg.visible_blockgroups_no > 0)
			znrg.visible_blockgroups_no--;
	}

	gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(da), NULL, NULL, NULL);
}

static GtkWidget *znr_gui_create_grid(void)
{
	GtkListItemFactory *factory;
	znr_blockgroup_item *bg_item;
	GtkSelectionModel *selection;
	GtkWidget *grid_view;
	unsigned int i;

	/* Initialize hash table for tracking drawing areas */
	if (znrg.drawing_areas) {
		g_hash_table_destroy(znrg.drawing_areas);
		znrg.visible_blockgroups_no = 0;
	}
	znrg.drawing_areas = g_hash_table_new(g_direct_hash, g_direct_equal);

	/* Create a blockgroup g_list */
	znrg.blockgroup_list = g_list_store_new(ZNR_TYPE_BLOCKGROUP_ITEM);
	for (i = 0; i < znr.nr_blockgroups; ++i) {
		bg_item = znr_blockgroup_item_new(i, &znr.blockgroups[i]);
		g_list_store_append(znrg.blockgroup_list, bg_item);
		g_object_unref(bg_item);
	}

	/* Use no_selection otherwise we see blockgroup 0 selected on start */
	selection = GTK_SELECTION_MODEL(gtk_no_selection_new(G_LIST_MODEL(znrg.blockgroup_list)));

	/* Setup widget behavior */
	factory = gtk_signal_list_item_factory_new();
	g_signal_connect(factory, "setup",
			 G_CALLBACK(znr_gui_grid_setup_cb), NULL);
	g_signal_connect(factory, "bind",
			 G_CALLBACK(znr_gui_grid_bind_cb), NULL);
	g_signal_connect(factory, "unbind",
			 G_CALLBACK(znr_gui_grid_unbind_cb), NULL);

	/* Create grid view */
	grid_view = gtk_grid_view_new(selection, factory);
	gtk_grid_view_set_max_columns(GTK_GRID_VIEW(grid_view), znrg.nr_col);
	gtk_grid_view_set_min_columns(GTK_GRID_VIEW(grid_view), znrg.nr_col);

	/* Make grid fit window */
	gtk_widget_set_halign(grid_view, GTK_ALIGN_FILL);
	gtk_widget_set_valign(grid_view, GTK_ALIGN_FILL);
	gtk_widget_set_hexpand(grid_view, TRUE);
	gtk_widget_set_vexpand(grid_view, TRUE);

	return grid_view;
}

/*
 * Called when the user resizes the window, adjusts the number of columns
 * accordingly
 */
static void window_size_changed_cb(GtkWidget *widget)
{
	unsigned int w = gtk_widget_get_width(widget);
	int blockgroup_da_w = 0;
	unsigned int max_cols;

	znr_gui_blockgroup_da_size(&blockgroup_da_w, NULL);
	if (!blockgroup_da_w || !w)
		return;
	/*
	 * Max cols we can fit into the current window without horizontal
	 * scrolling
	 */
	max_cols = w / blockgroup_da_w;
	max_cols = max_cols > 1 ? max_cols - 1 : max_cols;

	if (max_cols != znrg.nr_col) {
		znrg.nr_col = max_cols;
		gtk_grid_view_set_max_columns(GTK_GRID_VIEW(znrg.grid_view),
					      znrg.nr_col);
		gtk_grid_view_set_min_columns(GTK_GRID_VIEW(znrg.grid_view),
					      znrg.nr_col);
	}
}

static void znr_gui_create_app(GtkApplication *app, gpointer user_data)
{
	GtkWidget *top_vbox, *vbox, *frame, *hbox, *scroll_window, *bottom_row;
	GtkWidget *label, *da, *entry, *search_button;
	GtkWidget *zoom_label, *zoom_out_button, *zoom_in_button;
	GtkWidget *refresh_button, *refresh_toggle;
	GtkCssProvider *css_provider;
	char str[512];
	int n;

	/* Load CSS */
	css_provider = gtk_css_provider_new();
	gtk_css_provider_load_from_string(css_provider, znr_gui_css_data);
	gtk_style_context_add_provider_for_display(gdk_display_get_default(),
				GTK_STYLE_PROVIDER(css_provider),
				GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	g_object_unref(css_provider);

	if (znrg.window)
		return;

	/* Get colors */
	gdk_rgba_parse(&znrg.color_conv, "Magenta");
	gdk_rgba_parse(&znrg.color_seq, "#25bb00ff");
	gdk_rgba_parse(&znrg.color_seqw, "Red");
	gdk_rgba_parse(&znrg.color_text, "Black");
	gdk_rgba_parse(&znrg.color_jz, "Indigo");
	gdk_rgba_parse(&znrg.color_extent, "Gold");

	znrg.window = gtk_application_window_new(app);
	gtk_window_set_title(GTK_WINDOW(znrg.window), "Zonar");

	g_signal_connect(znrg.window, "notify::default-width",
			 G_CALLBACK(window_size_changed_cb), NULL);

	/* Top vbox */
	top_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
	gtk_window_set_child(GTK_WINDOW(znrg.window), top_vbox);

	/* Create a top frame */
	n = snprintf(str, sizeof(str) - 1,
		     "<b>%s</b> at <b>%s</b> (%u blockgroups) on <b>%s</b> ",
		     znr.mnt_dir.fs->name,
		     znr.mnt_dir.path, znr.nr_blockgroups,
		     znr.dev_path);
	if (!znr.nr_conv_zones)
		snprintf(str + n, sizeof(str) - (n + 1),
			 "(%u sequential zones)",
			 znr.nr_zones);
	else
		snprintf(str + n, sizeof(str) - (n + 1),
			 "(%u zones, %u conventional zones, %u sequential zones)",
			 znr.nr_zones, znr.nr_conv_zones,
			 znr.nr_zones - znr.nr_conv_zones);
	frame = gtk_frame_new(str);
	gtk_box_append(GTK_BOX(top_vbox), frame);
	gtk_label_set_use_markup(GTK_LABEL(gtk_frame_get_label_widget(GTK_FRAME(frame))),
				 TRUE);
	gtk_frame_set_label_align(GTK_FRAME(frame), 0.01);
	gtk_widget_set_margin_top(frame, 10);
	gtk_widget_set_margin_bottom(frame, 5);

	/*
	 * vbox for 2 hboxes: one for grid and scroll window, another for
	 * legend, zoom and refresh.
	 */
	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
	gtk_widget_set_margin_start(top_vbox, 10);
	gtk_widget_set_margin_end(top_vbox, 10);
	gtk_widget_set_margin_top(top_vbox, 10);
	gtk_widget_set_margin_bottom(top_vbox, 10);
	gtk_frame_set_child(GTK_FRAME(frame), vbox);

	/* hbox for grid and scroll window */
	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);
	gtk_box_append(GTK_BOX(vbox), hbox);

	/* Add a scrollable grid */
	scroll_window = gtk_scrolled_window_new();
	gtk_widget_set_margin_start(scroll_window, 10);
	gtk_widget_set_margin_end(scroll_window, 10);
	gtk_widget_set_margin_top(scroll_window, 10);
	gtk_widget_set_margin_bottom(scroll_window, 10);
	gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(scroll_window),
						   400);

	/*
	 * Use the natural size of the child (grid), and allow the scroll
	 * window to fill and expand relative to it's parent
	 */
	gtk_scrolled_window_set_min_content_width(GTK_SCROLLED_WINDOW(scroll_window),
						  -1);
	gtk_scrolled_window_set_propagate_natural_width(GTK_SCROLLED_WINDOW(scroll_window),
							TRUE);
        gtk_widget_set_halign(scroll_window, GTK_ALIGN_FILL);
        gtk_widget_set_vexpand(scroll_window, TRUE);
        gtk_widget_set_hexpand(scroll_window, TRUE);

	gtk_scrolled_window_set_has_frame(GTK_SCROLLED_WINDOW(scroll_window),
					  true);
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll_window),
                                       GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_box_append(GTK_BOX(hbox), scroll_window);

	znrg.scroll_window = scroll_window;

	/* Create scrollable grid view */
	znrg.grid_view = znr_gui_create_grid();
	gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scroll_window),
				      znrg.grid_view);

	/* hbox for legend, zoom and refresh button */
	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
	gtk_widget_set_margin_start(hbox, 10);
	gtk_widget_set_margin_end(hbox, 10);
	gtk_widget_set_margin_bottom(hbox, 20);
	gtk_widget_set_vexpand(hbox, FALSE);
	gtk_box_append(GTK_BOX(vbox), hbox);

	/* Legend drawing area */
	da = gtk_drawing_area_new();
	gtk_widget_set_hexpand(da, TRUE);
	gtk_widget_set_vexpand(da, TRUE);
	gtk_box_append(GTK_BOX(hbox), da);

	gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(da),
				       znr_gui_draw_legend_cb, NULL, NULL);

	/* Zoom controls label */
	zoom_label = gtk_label_new("Zoom:");
	gtk_box_append(GTK_BOX(hbox), zoom_label);

	/* Zoom out button */
	zoom_out_button = gtk_button_new_with_label("-");
	gtk_widget_set_tooltip_text(zoom_out_button,
				    "Zoom Out (Show more blockgroups)");
	gtk_box_append(GTK_BOX(hbox), zoom_out_button);
	g_signal_connect(zoom_out_button, "clicked",
			 G_CALLBACK(znr_gui_zoom_out_cb), NULL);

	/* Zoom in button */
	zoom_in_button = gtk_button_new_with_label("+");
	gtk_widget_set_tooltip_text(zoom_in_button,
				    "Zoom In (Show less blockgroups)");
	gtk_box_append(GTK_BOX(hbox), zoom_in_button);
	g_signal_connect(zoom_in_button, "clicked",
			 G_CALLBACK(znr_gui_zoom_in_cb), NULL);

	/* Refresh button */
	refresh_button = gtk_button_new_with_label("Refresh");
	gtk_widget_set_tooltip_text(refresh_button,
				    "Refresh blockgroups display");
	gtk_box_append(GTK_BOX(hbox), refresh_button);
	g_signal_connect(refresh_button, "clicked",
			 G_CALLBACK(znr_gui_refresh_cb), NULL);

	/* Blockgroup navigation label */
	snprintf(str, sizeof(str) - 1, "<b>Jump to blockgroup</b>");
	label = gtk_label_new(NULL);
	gtk_label_set_markup(GTK_LABEL(label), str);
	gtk_widget_set_margin_start(label, 10);
	gtk_label_set_xalign(GTK_LABEL(label), 0.0);
	gtk_box_append(GTK_BOX(hbox), label);

	/* Blockgroup navigation text entry */
	entry = gtk_entry_new();
	gtk_entry_set_placeholder_text(GTK_ENTRY(entry),
			"Enter blockgroup number...");
	gtk_widget_set_hexpand(entry, FALSE);
	gtk_widget_set_margin_end(entry, 10);
	gtk_box_append(GTK_BOX(hbox), entry);
	g_signal_connect(entry, "activate",
			 G_CALLBACK(znr_gui_show_blockgroup_cb), NULL);
	znrg.show_blockgroup_entry = entry;

	/* Go to blockgroup button */
	search_button = gtk_button_new_with_label("Show");
	gtk_box_append(GTK_BOX(hbox), search_button);
	g_signal_connect(search_button, "clicked",
			 G_CALLBACK(znr_gui_show_blockgroup_cb), NULL);

	/* Refresh interval text entry */
	entry = gtk_entry_new();
	gtk_entry_set_placeholder_text(GTK_ENTRY(entry), "Period (ms)");
	gtk_widget_set_tooltip_text(entry, "Auto refresh period (ms)");
	gtk_widget_set_hexpand(entry, FALSE);
	gtk_widget_set_margin_start(entry, 10);
	gtk_box_append(GTK_BOX(hbox), entry);
	znrg.refresh_ms_entry = entry;

	/* Auto-refresh toggle */
	refresh_toggle = gtk_toggle_button_new_with_label("Auto refresh");
	gtk_widget_set_tooltip_text(refresh_toggle,
				    "Toggle auto-refresh");
	gtk_widget_add_css_class(refresh_toggle, "auto-refresh");
	gtk_box_append(GTK_BOX(hbox), refresh_toggle);
	g_signal_connect(refresh_toggle, "toggled",
			 G_CALLBACK(znr_gui_refresh_ms_check_cb), NULL);

	/* Bottom Row */
	bottom_row = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
	gtk_box_append(GTK_BOX(top_vbox), bottom_row);

	/* Hover overview */
	frame = gtk_frame_new("<b>Blockgroup Status</b>");
	gtk_label_set_use_markup(GTK_LABEL(gtk_frame_get_label_widget(GTK_FRAME(frame))),
				 TRUE);
	gtk_frame_set_label_align(GTK_FRAME(frame), 0.01);
	gtk_box_append(GTK_BOX(bottom_row), frame);

	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
	gtk_widget_set_margin_start(hbox, 10);
	gtk_widget_set_margin_end(hbox, 10);
	gtk_widget_set_margin_top(hbox, 10);
	gtk_widget_set_margin_bottom(hbox, 10);
	gtk_frame_set_child(GTK_FRAME(frame), hbox);

	entry = gtk_entry_new();
	gtk_editable_set_editable(GTK_EDITABLE(entry), FALSE);
	gtk_entry_set_placeholder_text(GTK_ENTRY(entry),
				       "Hover on a blockgroup...");
	gtk_widget_set_hexpand(entry, TRUE);
	gtk_widget_set_halign(entry, GTK_ALIGN_FILL);
	gtk_box_append(GTK_BOX(hbox), entry);
	znrg.bg_status = entry;

	/* File search frame */
	frame = gtk_frame_new("<b>Search File</b>");
	gtk_label_set_use_markup(GTK_LABEL(gtk_frame_get_label_widget(GTK_FRAME(frame))),
				 TRUE);
	gtk_frame_set_label_align(GTK_FRAME(frame), 0.01);
	gtk_box_append(GTK_BOX(bottom_row), frame);
	gtk_widget_set_hexpand(frame, FALSE);
	gtk_widget_set_halign(frame, GTK_ALIGN_END);

	/* Input entry and button */
	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
	gtk_widget_set_margin_start(hbox, 10);
	gtk_widget_set_margin_end(hbox, 10);
	gtk_widget_set_margin_top(hbox, 10);
	gtk_widget_set_margin_bottom(hbox, 10);
	gtk_frame_set_child(GTK_FRAME(frame), hbox);

	/* FS mount path label */
	snprintf(str, sizeof(str) - 1, "<b>%s/</b>", znr.mnt_dir.path);
	label = gtk_label_new(NULL);
	gtk_label_set_markup(GTK_LABEL(label), str);
	gtk_widget_set_margin_start(label, 10);
	gtk_label_set_xalign(GTK_LABEL(label), 0.0);
	gtk_box_append(GTK_BOX(hbox), label);

	/* Text entry */
	entry = gtk_entry_new();
	gtk_entry_set_placeholder_text(GTK_ENTRY(entry),
			"Enter file path (relative to mount point)...");
	gtk_widget_set_hexpand(entry, TRUE);
	gtk_widget_set_margin_end(entry, 10);
	gtk_box_append(GTK_BOX(hbox), entry);
	g_signal_connect(entry, "activate",
			 G_CALLBACK(znr_gui_search_file_cb), NULL);
	znrg.search_entry = entry;

	/* Search button */
	search_button = gtk_button_new_with_label("Search");
	gtk_box_append(GTK_BOX(hbox), search_button);
	g_signal_connect(search_button, "clicked",
			 G_CALLBACK(znr_gui_search_file_cb), NULL);

	gtk_window_present(GTK_WINDOW(znrg.window));

	znr_gui_update();
}

static void znr_gui_destroy(void)
{
	znr_gui_close_extents_dialog();

	/* Cleanup drawing areas hash table */
	if (znrg.drawing_areas) {
		g_hash_table_destroy(znrg.drawing_areas);
		znrg.drawing_areas = NULL;
	}

	/* Cleanup signal handling resources */
	if (znrg.gio_channel) {
		g_io_channel_unref(znrg.gio_channel);
		znrg.gio_channel = NULL;
	}

	/* Close signal pipe file descriptors */
	if (znrg.sig_pipe[0] >= 0) {
		close(znrg.sig_pipe[0]);
		znrg.sig_pipe[0] = -1;
	}

	if (znrg.sig_pipe[1] >= 0) {
		close(znrg.sig_pipe[1]);
		znrg.sig_pipe[1] = -1;
	}
}

/*
 * Signal handling.
 */
static gboolean znr_gui_process_signal(GIOChannel *source,
				GIOCondition condition, gpointer user_data)
{
	GtkApplication *app = user_data;
	char buf[32];
	ssize_t size;

	if (condition & G_IO_IN) {
		size = read(g_io_channel_unix_get_fd(source), buf, sizeof(buf));
		if (size > 0) {
			/* Got signal */
			g_application_quit(G_APPLICATION(app));
			return TRUE;
		}
	}

	return FALSE;
}

static void znr_gui_sig_handler(int sig)
{
	/* Propagate signal through the pipe */
	if (write(znrg.sig_pipe[1], &sig, sizeof(int)) < 0)
		printf("Signal %d processing failed\n", sig);
}

static void znr_gui_set_signal_handlers(GtkApplication *app)
{
	long fd_flags;
	int ret;

	ret = pipe(znrg.sig_pipe);
	if (ret < 0) {
		perror("pipe");
		exit(1);
	}

	fd_flags = fcntl(znrg.sig_pipe[1], F_GETFL);
	if (fd_flags < 0) {
		perror("Read descriptor flags");
		exit(1);
	}
	ret = fcntl(znrg.sig_pipe[1], F_SETFL, fd_flags | O_NONBLOCK);
	if (ret < 0) {
		perror("Write descriptor flags");
		exit(1);
	}

	/* Install the unix signal handler */
	signal(SIGINT, znr_gui_sig_handler);
	signal(SIGQUIT, znr_gui_sig_handler);
	signal(SIGTERM, znr_gui_sig_handler);

	/* Convert the reading end of the pipe into a GIOChannel */
	znrg.gio_channel = g_io_channel_unix_new(znrg.sig_pipe[0]);
	g_io_channel_set_encoding(znrg.gio_channel, NULL, NULL);
	g_io_channel_set_flags(znrg.gio_channel,
			       g_io_channel_get_flags(znrg.gio_channel) |
			       G_IO_FLAG_NONBLOCK,
			       NULL);
	g_io_add_watch(znrg.gio_channel,
		       G_IO_IN | G_IO_PRI,
		       znr_gui_process_signal, app);
}

int znr_gui_run(void)
{
	GtkApplication *app;
	int ret;

	memset(&znrg, 0, sizeof(znrg));
	znrg.sig_pipe[0] = -1;
	znrg.sig_pipe[1] = -1;

	/* Set blockgroup grid defaults. */
	if (!znrg.nr_col && znr.nr_blockgroups < 100)
		znrg.nr_col = sqrt(znr.nr_blockgroups);
	if (!znrg.nr_col)
		znrg.nr_col = 8;
	znrg.nr_col_min = znrg.nr_col;

	znrg.zoom_level = ZNR_GUI_MAX_ZOOM_OUT;
	znrg.show_blockgroup = UINT_MAX;

	/* Create the main window */
	adw_init();
	app = gtk_application_new("org.wdc.zonar", G_APPLICATION_DEFAULT_FLAGS);
	g_signal_connect(app, "activate", G_CALLBACK(znr_gui_create_app),
			 NULL);

	znr_gui_set_signal_handlers(app);

	/*
	 * Run the GUI. We do not pass the command line args as handling of
	 * file opening is done here already, without GTK
	 * (G_APPLICATION_HANDLES_OPEN)
	 */
	ret = g_application_run(G_APPLICATION(app), 0, NULL);
	g_object_unref(app);
	znr_gui_destroy();

	return ret;
}
